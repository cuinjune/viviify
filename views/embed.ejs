<!DOCTYPE html>
<html>

<head>
  <title>viviify</title>
  <meta charset=utf-8 />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <meta name="viewport"
    content="user-scalable=no, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <link rel="icon" href="/asset/favicon/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="/css/embed.css" />
</head>

<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <img id="thumbnail" class="canvas-overlay" style="display: none;">
    <div id="loading-icon" class="canvas-overlay" style="pointer-events: none; opacity: 0;"></div>
    <div id="controller" class="canvas-overlay" style="opacity: 0;">
      <div id="controller-top">
        <div id="viviify-logo" style="pointer-events: none; opacity: 0;">
          <h2 id="viviify-text">viviify</h2>
        </div>
        <div id="share" style="pointer-events: none;">
          <div id="share-background" style="pointer-events: none; opacity: 0;">
            <form id="share-watch" class="share-form">
              <div id="share-watch-top" class="share-form-top">
                <h3 id="share-watch-text" class="share-form-text">Watch:</h3>
              </div>
              <div id="share-watch-bottom" class="share-form-bottom">
                <input id="share-watch-input" class="share-form-input" type="text"
                  value="https://viviify.com/watch/<%= urlKey %>" readonly>
                <input id="share-watch-copy" class="share-form-copy" type="submit" value="Copy">
              </div>
            </form>
            <form id="share-embed" class="share-form">
              <div id="share-embed-top" class="share-form-top">
                <h3 id="share-embed-text" class="share-form-text">Embed:</h3>
              </div>
              <div id="share-embed-bottom" class="share-form-bottom">
                <input id="share-embed-input" class="share-form-input" type="text"
                  value='<iframe src="https://viviify.com/embed/<%= urlKey %>" width="640" height="360" frameborder="0" allow="autoplay;" allowfullscreen></iframe>'
                  readonly>
                <input id="share-embed-copy" class="share-form-copy" type="submit" value="Copy">
              </div>
            </form>
          </div>
        </div>
      </div>
      <div id="controller-middle">
        <div id="progress-background">
          <div id="progress-bar">
            <div id="progress-loading">
              <div id="progress-gauge"></div>
              <div id="progress-thumb"></div>
            </div>
          </div>
        </div>
      </div>
      <div id="controller-bottom">
        <div id="controller-bottom-left">
          <div id="controller-play" class="controller-elem">
            <img id="controller-play-icon" class="controller-item" src="/asset/image/play.svg" alt="Play">
            <img id="controller-pause-icon" class="controller-item" src="/asset/image/pause.svg" alt="Pause">
            <img id="controller-replay-icon" class="controller-item" src="/asset/image/replay.svg" alt="Replay">
          </div>
          <div id="controller-backward" class="controller-elem">
            <img id="controller-backward-icon" class="controller-item" src="/asset/image/backward.svg" alt="Backward">
          </div>
          <div id="controller-forward" class="controller-elem">
            <img id="controller-forward-icon" class="controller-item" src="/asset/image/backward.svg" alt="Forward">
          </div>
        </div>
        <div id="controller-bottom-right">
          <div id="controller-share" class="controller-elem">
            <img id="controller-share-icon" class="controller-item" src="/asset/image/share.svg" alt="Share">
          </div>
          <div id="controller-fullscreen" class="controller-elem">
            <img id="controller-fullscreen-icon" class="controller-item" src="/asset/image/fullscreen.svg"
              alt="Fullscreen">
            <img id="controller-normalscreen-icon" class="controller-item" src="/asset/image/normalscreen.svg"
              alt="Normalscreen">
          </div>
        </div>
      </div>
    </div>
    <div id="change" class="canvas-overlay" style="pointer-events: none; opacity: 0;">
      <div id="change-top">
        <div id="change-top-center" class="change-top-elem">
          <div id="change-top-center-page0" class="change-top-item"></div>
          <div id="change-top-center-page1" class="change-top-item"></div>
          <div id="change-top-center-page2" class="change-top-item"></div>
          <div id="change-top-center-page3" class="change-top-item"></div>
          <div id="change-top-center-page4" class="change-top-item"></div>
          <div id="change-top-center-page5" class="change-top-item"></div>
        </div>
      </div>
      <div id="change-bottom">
        <div id="change-bottom-left" class="change-bottom-elem">
          <img id="change-bottom-left-icon" class="change-bottom-item" src="/asset/image/change.svg" alt="Left">
        </div>
        <div id="change-bottom-center"></div>
        <div id="change-bottom-right" class="change-bottom-elem">
          <img id="change-bottom-right-icon" class="change-bottom-item" src="/asset/image/change.svg" alt="Right">
        </div>
      </div>
    </div>
  </div>

  <script>
    window.addEventListener("load", () => {
      const container = document.getElementById("container");
      const canvas = document.getElementById("canvas");
      const thumbnail = document.getElementById("thumbnail");
      const loadingIcon = document.getElementById("loading-icon");
      const controller = document.getElementById("controller");
      const controllerTop = document.getElementById("controller-top");
      const viviifyLogo = document.getElementById("viviify-logo");
      const viviifyText = document.getElementById("viviify-text");
      const shareBackground = document.getElementById("share-background");
      const shareWatch = document.getElementById("share-watch");
      const shareWatchInput = document.getElementById("share-watch-input");
      const shareWatchCopy = document.getElementById("share-watch-copy");
      const shareEmbed = document.getElementById("share-embed");
      const shareEmbedInput = document.getElementById("share-embed-input");
      const shareEmbedCopy = document.getElementById("share-embed-copy");
      const controllerMiddle = document.getElementById("controller-middle");
      const progressBar = document.getElementById("progress-bar");
      const progressLoading = document.getElementById("progress-loading");
      const progressGauge = document.getElementById("progress-gauge");
      const progressThumb = document.getElementById("progress-thumb");
      const controllerBottom = document.getElementById("controller-bottom");
      const controllerPlay = document.getElementById("controller-play");
      const controllerPlayIcon = document.getElementById("controller-play-icon");
      const controllerPauseIcon = document.getElementById("controller-pause-icon");
      const controllerReplayIcon = document.getElementById("controller-replay-icon");
      const controllerBackward = document.getElementById("controller-backward");
      const controllerBackwardIcon = document.getElementById("controller-backward-icon");
      const controllerForward = document.getElementById("controller-forward");
      const controllerForwardIcon = document.getElementById("controller-forward-icon");
      const controllerShare = document.getElementById("controller-share");
      const controllerFullscreen = document.getElementById("controller-fullscreen");
      const controllerFullscreenIcon = document.getElementById("controller-fullscreen-icon");
      const controllerNormalscreenIcon = document.getElementById("controller-normalscreen-icon");
      const change = document.getElementById("change");
      const changeBottomLeft = document.getElementById("change-bottom-left");
      const changeBottomRight = document.getElementById("change-bottom-right");

      if (!"<%= urlKey %>".length) {
        container.innerHTML = "<h2>The video no longer exists</h2>";
        return;
      }

      // the following is just to fix the audio delay in Safari
      const AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext;
      let audioCtx = null;
      if (AudioContext) {
        audioCtx = new AudioContext();
      }
      const getSubtitleFontSize = () => {
        switch ("<%= subtitle %>") {
          case "off": return 0;
          case "tiny": return canvas.height * 0.03;
          case "small": return canvas.height * 0.04;
          case "medium": return canvas.height * 0.05;
          case "large": return canvas.height * 0.06;
          case "huge": return canvas.height * 0.07;
          default: return canvas.height * 0.05;
        }
      }
      const getSubtitleHeightRatio = () => {
        switch ("<%= subtitle %>") {
          case "off": return 0;
          case "tiny": return 0.15;
          case "small": return 0.2;
          case "medium": return 0.25;
          case "large": return 0.3;
          case "huge": return 0.35;
          default: return 0.25;
        }
      }
      const debugMode = false; // set debug mode
      const isSafari = /^((?!chrome|android|crios|fxios).)*safari/i.test(navigator.userAgent);
      const isIOS = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
      const isAndroid = /(android)/i.test(navigator.userAgent);
      const urlParams = new URLSearchParams(window.location.search);
      const autoLoadDefault = true;
      const autoPlayDefault = false;
      const autoLoad = (isSafari || isIOS) ? false : !urlParams.has("autoload") ? autoLoadDefault : urlParams.get("autoload") === "1" ? true : false; // can be enabled by adding "?autoload=1" after the URL (disabled in Safari and iOS)
      const autoPlay = (!autoLoad || !urlParams.has("autoplay")) ? autoPlayDefault : urlParams.get("autoplay") === "1" ? true : false; // can be enabled by adding "?autoplay=1" after the URL
      const pageLoadedTime = new Date();
      const ctx = canvas.getContext("2d");
      canvas.width = 1920;
      canvas.height = 1080;
      ctx.font = `${getSubtitleFontSize()}px Helvetica`;
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      ctx.lineWidth = getSubtitleFontSize() * 0.1;
      const subtitleWidthRatio = 0.9; // maximum subtitle width ratio
      const subtitleHeightRatio = getSubtitleHeightRatio(); // maximum subtitle height ratio
      const subtitleWidth = canvas.width * subtitleWidthRatio;
      const subtitleHeight = canvas.height * subtitleHeightRatio;
      const subtitlePosX = canvas.width * (1 - subtitleWidthRatio) / 2;
      const subtitlePosY = canvas.height * (1 - subtitleHeightRatio);
      const subtitleLineHeight = ctx.measureText("M").width * 1.75;
      const minDuration = 3000; // minimum required time to start playing the first video
      const progressBarWidthGap = 30; // progress bar has width of 100% - 30px
      const corsPrefix = "https://viviify.com:8080/";
      const brokenVideoIds = []; // array of broken video ids
      const videoData = {}; // data used to update segments (videoData[index] = { videos: [], videoIndex: 0 })
      let state = null;
      let keywords = [];
      let segments = [];
      let videoLength = 0;
      let segmentIndex = 0;
      let playingIndices = new Set();
      let startTime = 0;
      let previousProgress = 0;
      let previousTimestamp = 0;
      let progress = 0;
      let loadedProgress = 0;
      let hoverTimer = null;
      let controllerTopMouseUpTimer = null;
      let controllerMiddleClicked = false;
      let controllerMiddleClickedPreviousState = null;
      let buffering = false;
      let bufferingPreviousState = null;
      let loadingErrorCount = 0;
      let previousVideoIndex = -1;

      const STATE = Object.freeze({
        LOADED_PAGE: Symbol("LOADED_PAGE"),
        GETTING_SEGMENTS: Symbol("GETTING_SEGMENTS"),
        GOT_SEGMENTS: Symbol("GOT_SEGMENTS"),
        READY_TO_LOAD_MEDIA: Symbol("READY_TO_LOAD_MEDIA"),
        LOADING_AUDIOS: Symbol("LOADING_AUDIOS"),
        LOADED_AUDIOS: Symbol("LOADED_AUDIOS"),
        LOADING_VIDEOS: Symbol("LOADING_VIDEOS"),
        READY_TO_PLAY_VIDEOS: Symbol("READY_TO_PLAY_VIDEOS"),
        SHOULD_PLAY_VIDEOS: Symbol("SHOULD_PLAY_VIDEOS"),
        PLAYING_VIDEOS: Symbol("PLAYING_VIDEOS"),
        SHOULD_PAUSE_VIDEOS: Symbol("SHOULD_PAUSE_VIDEOS"),
        PAUSED_VIDEOS: Symbol("PAUSED_VIDEOS"),
        SHOULD_RESUME_VIDEOS: Symbol("SHOULD_RESUME_VIDEOS"),
        PLAYED_VIDEOS: Symbol("PLAYED_VIDEOS"),
        ERROR: Symbol("ERROR")
      });

      const printToConsole = (message) => {
        if (!debugMode) {
          return;
        }
        console.log(message);
      }

      const showController = () => {
        controller.style.opacity = 1;
        controller.style.cursor = "pointer";
        if (state === STATE.READY_TO_LOAD_MEDIA || state === STATE.READY_TO_PLAY_VIDEOS || state === STATE.PLAYED_VIDEOS) {
          return;
        }
        if (shareBackground.style.pointerEvents !== "none") {
          return;
        }
        change.style.opacity = 1;
        changeBottomLeft.style.pointerEvents = "auto";
        changeBottomRight.style.pointerEvents = "auto";
      }

      const hideController = () => {
        controller.style.opacity = 0;
        controller.style.cursor = "none";
        if (state === STATE.PLAYED_VIDEOS) {
          return;
        }
        if (shareBackground.style.pointerEvents !== "none") {
          return;
        }
        change.style.opacity = 0;
        changeBottomLeft.style.pointerEvents = "none";
        changeBottomRight.style.pointerEvents = "none";
      }

      const cancelHoverTimer = () => {
        if (hoverTimer) {
          window.clearTimeout(hoverTimer);
          hoverTimer = null;
        }
      }

      const scheduleHideController = () => {
        cancelHoverTimer();
        hoverTimer = window.setTimeout(() => {
          if (state !== STATE.PLAYING_VIDEOS) {
            return;
          }
          if (shareBackground.style.pointerEvents !== "none") {
            return;
          }
          if (controllerMiddleClicked) {
            return;
          }
          hideController();
        }, 1500);
      }

      // set current state
      const setState = (_state) => {
        if (state === _state) {
          return;
        }
        state = _state;
        switch (state) {
          case STATE.LOADED_PAGE:
            printToConsole("Successfully loaded the page");
            loadingIcon.style.opacity = 1;
            break;
          case STATE.GETTING_SEGMENTS:
            printToConsole("Getting segments...");
            break;
          case STATE.GOT_SEGMENTS:
            printToConsole("Successfully got segments");
            break;
          case STATE.READY_TO_LOAD_MEDIA:
            printToConsole("Ready to load media");
            thumbnail.style.display = "block";
            loadingIcon.style.opacity = 0;
            viviifyLogo.style.opacity = 1;
            viviifyText.style.pointerEvents = "auto";
            controllerPlayIcon.style.display = "block";
            controllerPauseIcon.style.display = "none";
            controllerReplayIcon.style.display = "none";
            controllerBackwardIcon.style.opacity = 0;
            controllerForwardIcon.style.opacity = 0;
            showController();
            break;
          case STATE.LOADING_AUDIOS:
            printToConsole("Loading audios...");
            loadingIcon.style.opacity = 1;
            break;
          case STATE.LOADED_AUDIOS:
            printToConsole("Successfully loaded audios");
            break;
          case STATE.LOADING_VIDEOS:
            printToConsole("Loading videos...");
            break;
          case STATE.READY_TO_PLAY_VIDEOS:
            printToConsole("Ready to play videos");
            loadingIcon.style.opacity = 0;
            showController();
            break;
          case STATE.SHOULD_PLAY_VIDEOS:
            printToConsole("Should play videos");
            thumbnail.style.display = "none";
            viviifyLogo.style.opacity = 0;
            viviifyText.style.pointerEvents = "none";
            controllerPlayIcon.style.display = "none";
            controllerPauseIcon.style.display = "block";
            controllerReplayIcon.style.display = "none";
            controllerBackwardIcon.style.opacity = 1;
            controllerForwardIcon.style.opacity = 1;
            hideController();
            break;
          case STATE.PLAYING_VIDEOS:
            printToConsole("Playing videos...");
            break;
          case STATE.SHOULD_PAUSE_VIDEOS:
            printToConsole("Should pause videos");
            controllerPlayIcon.style.display = "block";
            controllerPauseIcon.style.display = "none";
            controllerReplayIcon.style.display = "none";
            showController();
            break;
          case STATE.PAUSED_VIDEOS:
            printToConsole("Paused videos");
            break;
          case STATE.SHOULD_RESUME_VIDEOS:
            printToConsole("Should resume videos");
            controllerPlayIcon.style.display = "none";
            controllerPauseIcon.style.display = "block";
            controllerReplayIcon.style.display = "none";
            if (!buffering) {
              hideController();
            }
            else {
              scheduleHideController();
            }
            break;
          case STATE.PLAYED_VIDEOS:
            printToConsole("Played videos");
            viviifyLogo.style.opacity = 1;
            viviifyText.style.pointerEvents = "auto";
            controllerPlayIcon.style.display = "none";
            controllerPauseIcon.style.display = "none";
            controllerReplayIcon.style.display = "block";
            controllerBackwardIcon.style.opacity = 0;
            controllerForwardIcon.style.opacity = 0;
            change.style.opacity = 0;
            changeBottomLeft.style.pointerEvents = "none";
            changeBottomRight.style.pointerEvents = "none";
            showController();
            break;
          case STATE.ERROR:
            printToConsole("An error has occurred");
            while (container.firstChild) {
              container.removeChild(container.firstChild);
            }
            container.innerHTML = "<h2>An error has occurred</h2>";
            break;
          default:
            printToConsole("Unknown state");
        }
      }

      const startBuffering = () => {
        buffering = true;
        bufferingPreviousState = state;
        printToConsole("Buffering...");
        loadingIcon.style.opacity = 1;
        setState(STATE.SHOULD_PAUSE_VIDEOS);
      }

      const releaseBuffering = () => {
        printToConsole("Buffering done");
        loadingIcon.style.opacity = 0;
        if (bufferingPreviousState === STATE.PLAYING_VIDEOS) {
          setState(STATE.SHOULD_RESUME_VIDEOS);
        }
        bufferingPreviousState = null;
        buffering = false;
      }

      const pausePlayingMedia = () => {
        for (const segment of segments) {
          if (segment.type === "audio") {
            if (segment.elem && segment.elem.readyState && !segment.elem.paused) {
              segment.elem.pause();
            }
          }
          else if (segment.type === "video") {
            const video = segment.videos[segment.videoIndex];
            if (video && video.elem && video.elem.readyState && !video.elem.paused) {
              video.elem.pause();
            }
          }
        }
      }

      const stopPlayingMedia = () => {
        for (const segment of segments) {
          if (segment.type === "audio") {
            if (segment.elem && segment.elem.readyState) {
              if (!segment.elem.paused) {
                segment.elem.pause();
              }
              segment.elem.currentTime = 0;
            }
          }
          else if (segment.type === "video") {
            const video = segment.videos[segment.videoIndex];
            if (video && video.elem && video.elem.readyState) {
              if (!video.elem.paused) {
                video.elem.pause();
              }
              video.elem.currentTime = 0;
            }
          }
        }
      }

      const playAudio = (segment, elapsedTime, frameTime) => {
        // update media's currentTime if the difference is larger than frameTime
        const currentTime = (elapsedTime - segment.start) / 1000;
        if (Math.abs(currentTime - segment.elem.currentTime) > frameTime) {
          segment.elem.currentTime = currentTime;
        }
        if (state === STATE.PLAYING_VIDEOS) {
          const playPromise = segment.elem.play();
          if (playPromise) {
            playPromise.catch((error) => {
              printToConsole(error);
            });
          }
        }
      }

      const playVideo = (segment, video, elapsedTime, frameTime) => {
        // update media's currentTime if the difference is larger than frameTime
        const currentTime = (elapsedTime - segment.start) / 1000;
        if (Math.abs(currentTime - video.elem.currentTime) > frameTime) {
          video.elem.currentTime = currentTime;
        }
        if (state === STATE.PLAYING_VIDEOS) {
          const playPromise = video.elem.play();
          if (playPromise) {
            playPromise.catch((error) => {
              printToConsole(error);
            });
          }
        }
      }

      const updateChangeTopPages = (videoIndex) => {
        if (videoIndex === previousVideoIndex) {
          return;
        }
        for (let i = 0; i < 6; i++) {
          document.getElementById(`change-top-center-page${i}`).style.opacity = 0.5;
        }
        document.getElementById(`change-top-center-page${videoIndex}`).style.opacity = 1;
        previousVideoIndex = videoIndex;
      }

      const drawVideo = (video) => {
        ctx.drawImage(video.elem, video.xpos, video.ypos, video.width, video.height);
      }

      const drawSubtitle = (segment) => {
        let newSubtitlePosY = subtitlePosY - ((segment.lines.length - 1) * subtitleLineHeight) / 2;
        for (let i = 0; i < segment.lines.length; i++) {
          ctx.fillStyle = "rgb(0, 0, 0)";
          ctx.strokeText(segment.lines[i], subtitlePosX + subtitleWidth / 2, newSubtitlePosY + subtitleHeight / 2);
          ctx.fillStyle = "rgb(255, 255, 255)";
          ctx.fillText(segment.lines[i], subtitlePosX + subtitleWidth / 2, newSubtitlePosY + subtitleHeight / 2);
          newSubtitlePosY += subtitleLineHeight;
        }
      }

      // animation loop
      const animate = (timestamp) => {
        if (state === STATE.READY_TO_PLAY_VIDEOS) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < segments.length; i++) {
            if (segments[i].type === "video") {
              updateChangeTopPages(segments[i].videoIndex);
              const video = segments[i].videos[segments[i].videoIndex];
              if (video && video.elem && video.elem.readyState) {
                drawVideo(video);
              }
              break;
            }
          }
          for (let i = 0; i < segments.length; i++) {
            if (segments[i].type === "subtitle") {
              drawSubtitle(segments[i]);
              break;
            }
          }
        }
        if (state === STATE.SHOULD_PLAY_VIDEOS) {
          stopPlayingMedia();
          segmentIndex = 0;
          playingIndices = new Set();
          startTime = timestamp;
          previousTimestamp = timestamp - (1000 / 60);
          setState(STATE.PLAYING_VIDEOS);
        }
        if (state === STATE.SHOULD_PAUSE_VIDEOS) {
          pausePlayingMedia();
          segmentIndex = 0;
          playingIndices = new Set();
          setState(STATE.PAUSED_VIDEOS);
        }
        if (state === STATE.SHOULD_RESUME_VIDEOS) {
          setState(STATE.PLAYING_VIDEOS);
        }
        if (state === STATE.PLAYING_VIDEOS || state === STATE.PAUSED_VIDEOS) {
          if (state === STATE.PAUSED_VIDEOS || progress !== previousProgress) {
            startTime = timestamp - progress * videoLength;
          }
          const elapsedTime = timestamp - startTime;
          progress = Math.min(elapsedTime / videoLength, 1);

          if (!buffering && progress > loadedProgress) {
            startBuffering();
          }

          // update progress bar gauge
          progressGauge.style.width = `${progress * (window.innerWidth - progressBarWidthGap)}px`;

          previousProgress = progress;
          const frameTime = (timestamp - previousTimestamp) / 1000;
          previousTimestamp = timestamp;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // store started segments
          for (let i = segmentIndex; i < segments.length; i++) {
            if (segments[i].end <= elapsedTime) { // skip already finished segments
              continue;
            }
            if (segments[i].start <= elapsedTime) {
              playingIndices.add(i);
              if (i === segments.length - 1) { // if the last index was added, exit the loop
                segmentIndex = segments.length;
              }
            }
            else {
              if (segmentIndex !== i) {
                segmentIndex = i;
              }
              break;
            }
          }

          // process stored segments before end
          for (const index of playingIndices) {
            const segment = segments[index];
            if (segment.end > elapsedTime) {
              switch (segment.type) {
                case "audio":
                  if (segment.elem && segment.elem.readyState && segment.elem.paused) {
                    playAudio(segment, elapsedTime, frameTime);
                  }
                  break;
                case "video":
                  updateChangeTopPages(segment.videoIndex);
                  const video = segment.videos[segment.videoIndex];
                  if (video && video.elem && video.elem.readyState) {
                    if (video.elem.paused) {
                      playVideo(segment, video, elapsedTime, frameTime);
                    }
                    drawVideo(video);
                  }
                  break;
                case "subtitle":
                  drawSubtitle(segment);
                  break;
                default:
                  printToConsole("Unknown type");
                  setState(STATE.ERROR);
                  return;
              }
            }
            else {
              if (segment.type === "audio") {
                if (segment.elem && segment.elem.readyState && !segment.elem.paused) {
                  segment.elem.pause();
                }
              }
              else if (segment.type === "video") {
                const video = segment.videos[segment.videoIndex];
                if (video && video.elem && video.elem.readyState && !video.elem.paused) {
                  video.elem.pause();
                }
              }
              playingIndices.delete(index); // remove ended segments
            }
          }

          if (!playingIndices.size) {
            setState(STATE.PLAYED_VIDEOS);
          }
        }
        if (state === STATE.PLAYED_VIDEOS) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = segments.length - 1; i >= 0; i--) {
            if (segments[i].type === "video") {
              updateChangeTopPages(segments[i].videoIndex);
              const video = segments[i].videos[segments[i].videoIndex];
              if (video && video.elem && video.elem.readyState) {
                drawVideo(video);
              }
              break;
            }
          }
          for (let i = segments.length - 1; i >= 0; i--) {
            if (segments[i].type === "subtitle") {
              drawSubtitle(segments[i]);
              break;
            }
          }
        }
        window.requestAnimationFrame(animate);
      }
      setState(STATE.LOADED_PAGE);

      const loadVideo = (video) => {
        return new Promise((resolve, reject) => {
          video.elem.oncanplay = () => {
            video.elem.oncanplay = null; // prevent from being called again

            // calculate xpos, ypos, width, height of the video to fit into the canvas
            const wrh = video.elem.videoWidth / video.elem.videoHeight;
            let newWidth = canvas.width;
            let newHeight = newWidth / wrh;
            if (newHeight > canvas.height) {
              newHeight = canvas.height;
              newWidth = newHeight * wrh;
            }
            video.xpos = newWidth < canvas.width ? ((canvas.width - newWidth) / 2) : 0;
            video.ypos = newHeight < canvas.height ? ((canvas.height - newHeight) / 2) : 0;
            video.width = newWidth;
            video.height = newHeight;
            video.scale = newHeight / video.elem.videoHeight;
            video.elem.currentTime = 0;
            video.elem.volume = 0;
            video.elem.muted = true;
            resolve();
          };
          video.elem.onerror = (error) => {
            brokenVideoIds.push(video.id);
            reject(error);
          };
          video.elem.src = `${corsPrefix}${video.url}`;
          video.elem.load();
        });
      }

      const loadMedia = () => {

        // get subtitle lines from text
        const anySubtitleLineOverflow = (lines) => {
          for (const line of lines) {
            if (line.indexOf(" ") !== -1 && ctx.measureText(line).width > subtitleWidth) {
              return true;
            }
          }
          return false;
        }

        const splitSubtitleLine = (line, numChunks) => {
          const words = line.split(" ").filter(i => i);
          let lines = [];
          for (let i = numChunks; i > 0; i--) {
            lines.push(words.splice(0, Math.ceil(words.length / i)).join(" "));
          }
          return lines;
        }

        const getSubtitleLines = (line) => {
          let lines = [line];
          for (let numChunks = 2; anySubtitleLineOverflow(lines); numChunks++) {
            lines = splitSubtitleLine(line, numChunks);
          }
          return lines;
        }

        // get subtitle lines
        for (const segment of segments) {
          if (segment.type === "subtitle") {
            segment.lines = getSubtitleLines(segment.text);
          }
        }

        // load audio files
        setState(STATE.LOADING_AUDIOS);
        const promises = []; // array to store audio loading promises
        for (const segment of segments) {
          if (segment.type === "audio") {
            promises.push(
              new Promise((resolve, reject) => {
                segment.elem = new Audio();
                segment.elem.crossOrigin = "anonymous";
                segment.elem.oncanplaythrough = () => {
                  segment.elem.oncanplaythrough = null; // prevent from being called again
                  if ("<%= voice %>" === "off") {
                    segment.elem.volume = 0;
                  }
                  if (segment.end > videoLength) {
                    videoLength = segment.end;
                  }
                  resolve();
                };
                segment.elem.onerror = (error) => {
                  reject(error);
                };
                segment.elem.src = segment.url;
                segment.elem.load();
              })
            );
          }
        }
        Promise.all(promises).then(() => { // called after all audio files are loaded
          setState(STATE.LOADED_AUDIOS);
          printToConsole(`Total video duration: ${videoLength / 1000} seconds`);

          const onInitialLoad = () => {
            const loadingTime = new Date() - pageLoadedTime;
            printToConsole(`The initial loading took ${loadingTime}ms`);
            setState(STATE.READY_TO_PLAY_VIDEOS);
            if (!autoLoad || autoPlay) {
              setState(STATE.SHOULD_PLAY_VIDEOS);
            }
            window.requestAnimationFrame(animate);
          }

          // load video from text (one by one recursively)
          const loadVideosFromText = (index, duration) => {
            let segment = null;
            for (let i = index; i < segments.length; i++) {
              if (segments[i].type === "video") {
                segment = segments[i];
                index = i;
                duration += (segment.end - segment.start);
                break;
              }
            }
            if (segment == null) {
              printToConsole("Successfully loaded videos");
              // if it is still loading state, make it ready to play the video
              if (state === STATE.LOADING_VIDEOS) {
                onInitialLoad();
              }
              return;
            }
            const loadVideos = (segment, firstLoad) => {
              printToConsole("Loading videos...");
              for (const video of segment.videos) {
                video.elem = document.createElement("VIDEO");
                video.elem.crossOrigin = "anonymous";
              }
              // update the videoIndex to avoid using repeated video clip
              if (firstLoad) {
                for (let i = 0; i < index; i++) {
                  if (segments[i].type === "video") {
                    if (segments[i].videos[segments[i].videoIndex].id === segment.videos[segment.videoIndex].id) {
                      segment.videoIndex = (segment.videoIndex + 1) % segment.videos.length;
                    }
                  }
                }
              }
              // load video at current videoIndex
              const video = segment.videos[segment.videoIndex];
              loadVideo(video).then(() => {

                // ready to play the video
                if (state === STATE.LOADING_VIDEOS && duration >= minDuration) {
                  onInitialLoad();
                }

                // if it was buffering, release it
                if (buffering) {
                  releaseBuffering();
                }
                // update progress bar loading
                loadedProgress = segment.end / videoLength;
                progressLoading.style.width = `${loadedProgress * (window.innerWidth - progressBarWidthGap)}px`;

                // add video data
                const videos = [];
                for (const video of segment.videos) {
                  videos.push({ url: video.url, id: video.id }); // only need to save url and id
                }
                videoData[index] = { videos: videos, videoIndex: segment.videoIndex };

                // reset loading error count
                loadingErrorCount = 0;

                // call back this function with the next index
                loadVideosFromText(index + 1, duration);
              }).catch((error) => {
                if (loadingErrorCount >= 5) {
                  setState(STATE.ERROR);
                  return;
                }
                printToConsole(`Failed to load a video from ${video.url}`);
                printToConsole("Getting other video...");
                segment.videos = [];
                loadingErrorCount++;
                // call back this function with the current index
                loadVideosFromText(index, duration);
              });
            }
            if (segment.videos.length) {
              loadVideos(segment, false);
              return;
            }
            fetch("/api/v1/video", {
              method: "POST",
              headers: { "Accept": "application/json", "Content-Type": "application/json" },
              body: JSON.stringify({ text: segment.text, keywords: keywords, duration: (segment.end - segment.start) / 1000, videoIds: brokenVideoIds })
            }).then(response => response.json()).then((data) => {
              if (data.error) {
                alert(data.message);
                setState(STATE.ERROR);
                return;
              }
              if (!data.auth) {
                alert(data.message);
                setState(STATE.ERROR);
                return;
              }
              const { videos } = data;
              segment.videos = videos;
              loadVideos(segment, true);
            });
          }
          setState(STATE.LOADING_VIDEOS);
          loadVideosFromText(0, 0);
        }).catch((error) => {
          alert(error);
          setState(STATE.ERROR);
        });
      }

      const showShareBackground = () => {
        change.style.opacity = 0;
        changeBottomLeft.style.pointerEvents = "none";
        changeBottomRight.style.pointerEvents = "none";
        shareBackground.style.opacity = 1;
        shareBackground.style.pointerEvents = "auto";
        window.parent.postMessage({ id: "SHOULD_UPDATE_SEGMENTS", videoData: videoData }, "*");
      }

      const hideShareBackground = () => {
        clearSelection();
        shareBackground.style.opacity = 0;
        shareBackground.style.pointerEvents = "none";
        shareWatchCopy.value = "Copy";
        shareEmbedCopy.value = "Copy";
        change.style.opacity = 1;
        changeBottomLeft.style.pointerEvents = "auto";
        changeBottomRight.style.pointerEvents = "auto";
      }

      const copyToClipboard = (inputElem) => {
        inputElem.select();
        inputElem.setSelectionRange(0, 99999);
        try { // security exception may be thrown by some browsers.
          return document.execCommand("copy");
        }
        catch (error) {
          return false;
        }
      }

      const clearSelection = () => {
        if (window.getSelection) {
          window.getSelection().removeAllRanges();
        }
        else if (document.selection) {
          document.selection.empty();
        }
      }

      const playPauseResume = () => {
        if (buffering) {
          return;
        }
        if (state === STATE.READY_TO_LOAD_MEDIA) {
          loadMedia();
        }
        else if (state === STATE.READY_TO_PLAY_VIDEOS || state === STATE.PLAYED_VIDEOS) {
          setState(STATE.SHOULD_PLAY_VIDEOS);
        }
        else if (state === STATE.PLAYING_VIDEOS) {
          setState(STATE.SHOULD_PAUSE_VIDEOS);
        }
        else if (state === STATE.PAUSED_VIDEOS) {
          setState(STATE.SHOULD_RESUME_VIDEOS);
        }
      }

      const moveWhileClicked = (clientX) => {
        let xpos = clientX; // x position within the viewport
        const progressBarWidthGapHalf = progressBarWidthGap / 2;
        // ignore clicking outside the progress bar width
        if (xpos < progressBarWidthGapHalf || xpos > window.innerWidth - progressBarWidthGapHalf) {
          return;
        }
        xpos -= progressBarWidthGapHalf; // update x position for progress bar
        // ignore clicking above the loaded progress width 
        if (xpos > parseFloat(progressLoading.style.width)) {
          return;
        }
        progressGauge.style.width = `${xpos}px`;
        pausePlayingMedia();
        progress = Math.min(xpos / (window.innerWidth - progressBarWidthGap), (videoLength - 1) / videoLength);
        segmentIndex = 0;
        playingIndices = new Set();
      }

      const controllerMiddleOnMouseDown = (clientX) => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        if (controllerMiddleClicked) {
          return;
        }
        moveWhileClicked(clientX);
        controllerMiddleClickedPreviousState = state;
        setState(STATE.PAUSED_VIDEOS);
        controllerMiddleClicked = true;
      }

      const preventHidingController = () => {
        cancelHoverTimer();
        showController();
      }

      const windowOnMouseMove = (clientX) => {
        if (!controllerMiddleClicked) {
          return;
        }
        progressBar.style.height = "8px";
        progressThumb.style.webkitTransform = "scale(1)";
        progressThumb.style.transform = "scale(1)";
        moveWhileClicked(clientX);
      }

      const windowOnMouseUp = () => {
        if (!controllerMiddleClicked) {
          return;
        }
        progressBar.style.height = "4px";
        progressThumb.style.webkitTransform = "scale(0)";
        progressThumb.style.transform = "scale(0)";
        if (controllerMiddleClickedPreviousState === STATE.PLAYING_VIDEOS) {
          setState(STATE.SHOULD_RESUME_VIDEOS);
        }
        showController();
        scheduleHideController();
        controllerMiddleClickedPreviousState = null;
        controllerMiddleClicked = false;
      }

      const moveBackward = () => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        if (buffering) {
          releaseBuffering();
        }
        let currentTime = progress * videoLength;
        let currentIndex = -1;
        for (let i = segments.length - 1; i >= 0; i--) {
          if (segments[i].type === "subtitle" && segments[i].start <= currentTime) {
            currentIndex = i;
            break;
          }
        }
        if (currentIndex === -1) {
          return;
        }
        const currentSegment = segments[currentIndex];
        if (currentTime - currentSegment.start > 500) {
          currentTime = currentSegment.start;
        }
        else {
          let previousIndex = -1;
          for (let i = currentIndex - 1; i >= 0; i--) {
            if (segments[i].type === "subtitle" && segments[i].start < currentSegment.start) {
              previousIndex = i;
              break;
            }
          }
          if (previousIndex === -1) {
            currentTime = currentSegment.start;
          }
          else {
            const previousSegment = segments[previousIndex];
            currentTime = previousSegment.start;
          }
        }
        pausePlayingMedia();
        progress = currentTime / videoLength;
        segmentIndex = 0;
        playingIndices = new Set();
      }

      const moveForward = () => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        if (buffering) {
          return;
        }
        let currentTime = progress * videoLength;
        let currentIndex = -1;
        for (let i = segments.length - 1; i >= 0; i--) {
          if (segments[i].type === "subtitle" && segments[i].start <= currentTime) {
            currentIndex = i;
            break;
          }
        }
        if (currentIndex === -1) {
          return;
        }
        const currentSegment = segments[currentIndex];
        let nextIndex = -1;
        for (let i = currentIndex + 1; i < segments.length; i++) {
          if (segments[i].type === "subtitle" && segments[i].start > currentSegment.start) {
            nextIndex = i;
            break;
          }
        }
        if (nextIndex === -1) {
          currentTime = currentSegment.end - 1;
        }
        else {
          const nextSegment = segments[nextIndex];
          currentTime = nextSegment.start + 1;
        }
        const targetProgress = currentTime / videoLength;
        if (targetProgress > loadedProgress) {
          startBuffering();
          return;
        }
        pausePlayingMedia();
        progress = targetProgress;
        segmentIndex = 0;
        playingIndices = new Set();
      }

      const onFullscreenChange = () => {
        const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        if (fullscreenElement) {
          controllerFullscreenIcon.style.display = "none";
          controllerNormalscreenIcon.style.display = "block";
        }
        else {
          controllerFullscreenIcon.style.display = "block";
          controllerNormalscreenIcon.style.display = "none";
        }
      }

      const toggleFullscreen = () => {
        const fullscreenEnabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
        const requestFullscreen = document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.mozRequestFullScreen || document.documentElement.msRequestFullscreen;
        const exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.mozExitFullScreen || document.msExitFullscreen;
        if (!fullscreenEnabled || !requestFullscreen || !exitFullscreen) {
          alert("Fullscreen is not available in this browser");
          return;
        }
        const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        if (!fullscreenElement) {
          requestFullscreen.call(container);
          if ((isIOS || isAndroid) && screen.orientation && screen.orientation.lock) {
            screen.orientation.lock("landscape");
          }
        }
        else {
          exitFullscreen.call(document);
        }
      }

      const changeVideoIndex = (incrementIndex, step) => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        if (buffering) {
          return;
        }
        const currentTime = progress * videoLength;
        let currentIndex = -1;
        for (let i = segments.length - 1; i >= 0; i--) {
          if (segments[i].type === "video" && segments[i].start <= currentTime) {
            currentIndex = i;
            break;
          }
        }
        if (currentIndex === -1) {
          return;
        }
        const segment = segments[currentIndex];
        let newVideoIndex = incrementIndex ? segment.videoIndex + step : segment.videoIndex - step;
        if (newVideoIndex >= segment.videos.length) {
          newVideoIndex = newVideoIndex - segment.videos.length;
        }
        else if (newVideoIndex <= -1) {
          newVideoIndex = segment.videos.length + newVideoIndex;
        }

        const video = segment.videos[segment.videoIndex];
        if (video && video.elem && video.elem.readyState) {

          const newVideo = segment.videos[newVideoIndex];
          if (newVideo && newVideo.elem && !newVideo.elem.readyState) {
            startBuffering();
            loadVideo(newVideo).then(() => {
              // if it was buffering, release it
              if (buffering) {
                releaseBuffering();
              }

              // update video index
              segment.videoIndex = newVideoIndex;
              videoData[currentIndex].videoIndex = newVideoIndex;

              // unload the previous video
              if (!video.elem.paused) {
                video.elem.pause();
              }
              video.elem.oncanplay = null;
              video.elem.onerror = null;
              video.elem.removeAttribute("src"); // empty source
              video.elem.load();
            }).catch((error) => {
              printToConsole(`Failed to load a video from ${newVideo.url}`);

              // if it was buffering, release it
              if (buffering) {
                releaseBuffering();
              }
              // increment/decrement to the next step
              changeVideoIndex(incrementIndex, step + 1);
            });
          }
        }
      }

      // get segments
      setState(STATE.GETTING_SEGMENTS);
      fetch("/api/v1/project/<%= urlKey %>", {
        method: "GET"
      }).then(response => response.json()).then((data) => {
        if (data.error) {
          alert(data.message);
          setState(STATE.ERROR);
          return;
        }
        if (!data.auth) {
          alert(data.message);
          setState(STATE.ERROR);
          return;
        }
        setState(STATE.GOT_SEGMENTS);
        keywords = data.project.keywords;
        segments = data.project.segments;
        if (!segments.length) {
          while (container.firstChild) {
            container.removeChild(container.firstChild);
          }
          container.innerHTML = "<h2>The video no longer exists</h2>";
          return;
        }

        const getFirstVideoSegment = () => {
          for (const segment of segments) {
            if (segment.type === "video") {
              return segment;
            }
          }
        }
        const segment = getFirstVideoSegment();

        const loadThumbnail = () => {
          const thumbnailUrl = `https://i.vimeocdn.com/video/${segment.videos[segment.videoIndex].id}_1920x1080.jpg`;
          thumbnail.onerror = () => {
            printToConsole(`Could not load thumbnail from ${thumbnailUrl}`);
          };
          thumbnail.src = thumbnailUrl;
        }

        const onReadyToLoadMedia = () => {
          if (autoLoad) {
            if (!autoPlay) {
              loadThumbnail();
            }
            loadMedia();
          }
          else {
            loadThumbnail();
          }
        }

        if (segment.videos.length) {
          setState(STATE.READY_TO_LOAD_MEDIA);
          onReadyToLoadMedia();
          return;
        }
        fetch("/api/v1/video", {
          method: "POST",
          headers: { "Accept": "application/json", "Content-Type": "application/json" },
          body: JSON.stringify({ text: segment.text, keywords: keywords, duration: (segment.end - segment.start) / 1000, videoIds: brokenVideoIds })
        }).then(response => response.json()).then((data) => {
          if (data.error) {
            alert(data.message);
            setState(STATE.ERROR);
            return;
          }
          if (!data.auth) {
            alert(data.message);
            setState(STATE.ERROR);
            return;
          }
          const { videos } = data;
          segment.videos = videos;
          setState(STATE.READY_TO_LOAD_MEDIA);
          onReadyToLoadMedia();
        });
      });

      // add event listeners
      controller.addEventListener("mouseleave", (event) => {
        const target = event.toElement || event.relatedTarget;
        if (target && target.className === "change-bottom-elem") { // ignore leaving to the change elements
          return;
        }
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        if (shareBackground.style.pointerEvents !== "none") {
          return;
        }
        if (controllerMiddleClicked) {
          return;
        }
        if (buffering) {
          return;
        }
        controller.style.opacity = 0;
        change.style.opacity = 0;
      });

      controllerTop.addEventListener("mousemove", () => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        showController();
        scheduleHideController();
      });

      controllerTop.addEventListener("mouseup", () => {
        if (shareBackground.style.pointerEvents !== "none") {
          hideShareBackground();
          return;
        }
        if (controllerTopMouseUpTimer) {
          window.clearTimeout(controllerTopMouseUpTimer);
          controllerTopMouseUpTimer = null;
          toggleFullscreen();
          return;
        }
        controllerTopMouseUpTimer = window.setTimeout(() => {
          playPauseResume();
          controllerTopMouseUpTimer = null;
        }, 250);
      });

      viviifyText.addEventListener("mouseup", (event) => {
        event.stopPropagation();
        window.open("/watch/<%= urlKey %>");
      });

      shareBackground.addEventListener("mouseup", (event) => {
        event.stopPropagation();
      });

      shareWatch.addEventListener("submit", (event) => {
        event.preventDefault();
        if (copyToClipboard(shareWatchInput)) {
          shareWatchCopy.value = "Copied";
          shareEmbedCopy.value = "Copy";
        }
      });

      shareEmbed.addEventListener("submit", (event) => {
        event.preventDefault();
        if (copyToClipboard(shareEmbedInput)) {
          shareWatchCopy.value = "Copy";
          shareEmbedCopy.value = "Copied";
        }
      });

      controllerMiddle.addEventListener("touchstart", (event) => {
        controllerMiddleOnMouseDown(event.touches[0].clientX);
        event.preventDefault();
      });

      controllerMiddle.addEventListener("mousedown", (event) => {
        controllerMiddleOnMouseDown(event.clientX);
      });

      controllerMiddle.addEventListener("mousemove", () => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        if (controllerMiddleClicked) {
          return;
        }
        preventHidingController();
      });

      window.addEventListener("touchmove", (event) => {
        windowOnMouseMove(event.touches[0].clientX);
      });

      window.addEventListener("mousemove", (event) => {
        windowOnMouseMove(event.clientX);
      });

      window.addEventListener("touchend", (event) => {
        windowOnMouseUp();
      });

      window.addEventListener("mouseup", () => {
        windowOnMouseUp();
      });

      window.addEventListener("resize", (event) => {
        progressLoading.style.width = `${loadedProgress * (window.innerWidth - progressBarWidthGap)}px`;
        progressGauge.style.width = `${progress * (window.innerWidth - progressBarWidthGap)}px`;
      });

      controllerBottom.addEventListener("mousemove", () => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        preventHidingController();
      });

      controllerPlay.addEventListener("mouseup", () => {
        playPauseResume();
        showController();
        scheduleHideController();
      });

      controllerBackward.addEventListener("mouseup", () => {
        moveBackward();
      });

      controllerForward.addEventListener("mouseup", () => {
        moveForward();
      });

      controllerShare.addEventListener("mouseup", () => {
        if (shareBackground.style.pointerEvents === "none") {
          showShareBackground();
        }
        else {
          hideShareBackground();
        }
      });

      controllerFullscreen.addEventListener("mouseup", () => {
        toggleFullscreen();
      });

      changeBottomLeft.addEventListener("mousemove", () => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        preventHidingController();
      });

      changeBottomRight.addEventListener("mousemove", () => {
        if (state !== STATE.PLAYING_VIDEOS && state !== STATE.PAUSED_VIDEOS) {
          return;
        }
        preventHidingController();
      });

      changeBottomLeft.addEventListener("mouseup", () => {
        changeVideoIndex(false, 1);
        showController();
        scheduleHideController();
      });

      changeBottomRight.addEventListener("mouseup", () => {
        changeVideoIndex(true, 1);
        showController();
        scheduleHideController();
      });

      document.addEventListener("fullscreenchange", onFullscreenChange);
      document.addEventListener("webkitfullscreenchange", onFullscreenChange);
      document.addEventListener("mozfullscreenchange", onFullscreenChange);
      document.addEventListener("MSFullscreenChange", onFullscreenChange);

      document.addEventListener("keydown", (event) => {
        switch (event.key.toLowerCase()) {
          case " ":
            playPauseResume();
            break;
          case "arrowleft":
            moveBackward();
            break;
          case "arrowright":
            moveForward();
            break;
          case "arrowup":
            break;
          case "arrowdown":
            break;
          case "f":
            toggleFullscreen();
            break;
          case ",":
            changeVideoIndex(false, 1);
            break;
          case ".":
            changeVideoIndex(true, 1);
            break;
        }
      });

      // receive message from parent window
      const eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
      const eventer = window[eventMethod];
      const messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";
      eventer(messageEvent, (event) => {
        if (event.data.id === "SHOULD_SEND_VIDEO_DATA") {
          window.parent.postMessage({ id: "SHOULD_UPDATE_SEGMENTS", videoData: videoData }, "*");
        }
      });

      // pause the playing video if the page becomes inactive
      document.addEventListener("visibilitychange", () => {
        if (document.hidden && state === STATE.PLAYING_VIDEOS) {
          pausePlayingMedia();
          setState(STATE.SHOULD_PAUSE_VIDEOS);
        }
      });
    });
  </script>
</body>

</html>